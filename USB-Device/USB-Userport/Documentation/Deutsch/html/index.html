<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>USB-Userport: USB-Userport</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">USB-Userport
   </div>
   <div id="projectbrief">PC-Programme nutzen die generische HID Klasse zur Verbindung mit elektronischen Experimenten.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Erzeugt von Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Suchen');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Suchen');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">USB-Userport </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Vor vielen, vielen Jahren gab es für Hardware-Hacker, Computer-Fans und Elektronik-Entwickler einfach erreichbare Schnittstellen am Computer. Einfach erreichbar sowohl von der Aussenseite des Computers als auch von dessen Innerem. Man brauchte nur einen passenden Steckverbinder, ein bißchen Verdrahtung und die geeignete Programmierung.</p>
<p>Moderne Betriebssysteme machen es uns dagegen sehr schwer direkt auf Hardware-Schnittstellen zuzugreifen. Spezielle Treiber kann man sich zwar aus dem Internet holen aber da ist immer das Risiko unbekannter Software und man muss den Installern auch noch Administrator-Rechte einräumen. Nicht jeder hat allerdings die nötigen Rechte (oder will sie nutzen). Das gilt besonders für die Labore großer Unternehmen oder den Ausbildungsbereich.</p>
<p>Aber selbst wenn diese Einschränkungen für den eigenen PC nicht gelten, verfügen aktuelle Computermodelle gar nicht mehr über die altgedienten Schnittstellen um sie wie früher zu benutzen. Stattdessen ist USB weit verbreitet. Glücklicherweise bieten die modernen Betriebssysteme, die den direkten Hardwarezugriff nach Kräften verwehren, generische Treiberklassen für diverse USB-Gerätschaften. Glücklicherweise gibt es den Arduino-Mikrokosmos, gedacht für Ausbildungszwecke. Aus der Ecke gibt es kostengünstige Modelle, die an den USB angeschlossen werden können - ohne den Umweg über einen USB-nach-Seriell Adapter. Und erfreulicherweise gibt es für genau diese Arduinos mit Atmel µCs und deren USB-Möglichkeiten Dean Cameras wunderbares <a href="http://www.lufa-lib.org">LUFA-Projekt</a>.</p>
<p>Nehme ich alle diese Teile zusammen und lerne die generischen USB-Treiber des Betriebssystems zu nutzen, kann ich ein Gerät bauen durch das ich wieder direkt aus meinem PC-Programm heraus auf Hardware-Leitungen zugreifen kann. Gut, das geht nicht ganz so direkt mit <code>in</code> und <code>out</code> Befehlen wie früher. Aber immerhin öffnet das die Tür zu den feinen Sachen, die moderne Computer nicht (mehr) bieten.</p>
<h1><a class="anchor" id="Sec_Info"></a>
USB Information</h1>
<p>Die nachfolgende Tabelle soll eine kleine Übersicht geben welche Eigenschaften der USB-Userport als USB-Gerät aufweist.</p>
<table class="doxtable">
<tr>
<td><b>USB Klasse:</b>  </td><td>Human Interface Device (HID) </td></tr>
<tr>
<td><b>USB Unterklasse:</b>  </td><td>N/A  </td></tr>
<tr>
<td><b>USB Modus:</b>  </td><td>Device  </td></tr>
<tr>
<td><b>Hersteller ID (VID):</b>  </td><td>0x04D8  </td></tr>
<tr>
<td><b>Produkt ID (PID):</b>  </td><td>0xEBC7  </td></tr>
<tr>
<td><b>Stromaufnahme max.:</b>  </td><td>100 mA  </td></tr>
<tr>
<td><b>Polling-Intervall:</b>  </td><td>5 ms  </td></tr>
<tr>
<td><b>Maßgebliche Standards:</b> </td><td><a href="https://www.usb.org/sites/default/files/documents/hid1_11.pdf">USBIF HID Specification</a> <br  />
 <a href="https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf">USBIF HID Usage Tables</a> </td></tr>
<tr>
<td><b>Unterstützte USB Geschwindigkeit:</b>  </td><td>Full Speed Mode <br  />
 (Low Speed Mode) </td></tr>
</table>
<p>Der vorgestellt USB-Userport wird für den Full Speed Mode übersetzt. Das LUFA unterstützt auch die Übersetzung als Gerät im Low Speed Mode. Das habe ich nicht getestet und ich empfehle es auch nicht.</p>
<h1><a class="anchor" id="Sec_Description"></a>
Projektbeschreibung</h1>
<p>Das USB-Userport-Projekt verwandelt einen <a href="https://www.sparkfun.com/products/12640">Sparkfun ProMicro</a> in eine nützliche Hardwareschnittstelle für jedes PC-Programm. Möglicherweise eignet sich auch ein <a href="https://www.sparkfun.com/products/15795">Sparkfun Qwiic Pro Micro</a> ohne Änderungen. Der USB-Userport 'leiht' seine Ein- und Ausgabeleitungen dem PC-Programm ohne einen speziellen Treiber zu benötigen. Die Kommunikation übernimmt der generische HID-Treiber des Betriebssystems. Das PC-Programm kann die Schnittstellenleitungen mittels zugehöriger USB-Reports ansprechen. Die Zuordnung zwischen USB-Definition und ProMicro-Anschlüssen ist wie folgt: </p><table class="doxtable">
<tr>
<th><b>USB-Userport</b>  </th><th><b>ProMicro</b>  </th></tr>
<tr>
<td>LED[0]  </td><td>RX-LED  </td></tr>
<tr>
<td>LED[1]  </td><td>TX-LED  </td></tr>
<tr>
<td>GPIO1[0]  </td><td>-n/a-  </td></tr>
<tr>
<td>GPIO1[1]  </td><td>15  </td></tr>
<tr>
<td>GPIO1[2]  </td><td>16  </td></tr>
<tr>
<td>GPIO1[3]  </td><td>14  </td></tr>
<tr>
<td>GPIO1[4]  </td><td>8  </td></tr>
<tr>
<td>GPIO1[5] - Servo 1  </td><td>9  </td></tr>
<tr>
<td>GPIO1[6] - Servo 2  </td><td>10  </td></tr>
<tr>
<td>GPIO1[7]  </td><td>5  </td></tr>
<tr>
<td>GPIO1[8]  </td><td>3  </td></tr>
<tr>
<td>GPIO1[9]  </td><td>2  </td></tr>
<tr>
<td>GPIO1[10]  </td><td>0  </td></tr>
<tr>
<td>GPIO1[11]  </td><td>1  </td></tr>
<tr>
<td>GPIO1[12]  </td><td>4  </td></tr>
<tr>
<td>GPIO1[13]  </td><td>-n/a-  </td></tr>
<tr>
<td>GPIO1[14]  </td><td>7  </td></tr>
<tr>
<td>GPIO1[15]  </td><td>6  </td></tr>
<tr>
<td>GPIO2[0]  </td><td>-n/a-  </td></tr>
<tr>
<td>GPIO2[1]  </td><td>-n/a-  </td></tr>
<tr>
<td>GPIO2[2]  </td><td>-n/a-  </td></tr>
<tr>
<td>GPIO2[3]  </td><td>-n/a-  </td></tr>
<tr>
<td>GPIO2[4] - ADC[4]  </td><td>21  </td></tr>
<tr>
<td>GPIO2[5] - ADC[5]  </td><td>20  </td></tr>
<tr>
<td>GPIO2[6] - ADC[6]  </td><td>19  </td></tr>
<tr>
<td>GPIO2[7] - ADC[7]  </td><td>18  </td></tr>
<tr>
<td>GPIO2[8]  </td><td>-n/a-  </td></tr>
<tr>
<td>GPIO2[9]  </td><td>-n/a-  </td></tr>
<tr>
<td>GPIO2[10]  </td><td>-n/a-  </td></tr>
<tr>
<td>GPIO2[11]  </td><td>-n/a-  </td></tr>
<tr>
<td>GPIO2[12]  </td><td>-n/a-  </td></tr>
<tr>
<td>GPIO2[13]  </td><td>-n/a-  </td></tr>
<tr>
<td>GPIO2[14]  </td><td>-n/a-  </td></tr>
<tr>
<td>GPIO2[15]  </td><td>-n/a-  </td></tr>
</table>
<p>Wenn der USB-Userport an den USB-Host angeschlossen wird, wird er als benutzerdefiniertes USB-HID-Gerät erkannt und im System bereitgestellt. Das PC-Programm kann dann die verfügbaren Reports senden und empfangen, so wie die Definitionen der <a href="https://www.usb.org/sites/default/files/documents/hid1_11.pdf">USB HID specification</a> das vorgeben.</p>
<p>Ein spezieller Feature-Report lässt den USB-Userport zu seinem eingebauten Bootlader zurückspringen. Das ist für die Entwicklung vorgesehen, kann sich aber auch für andere Zwecke als nützlich erweisen.</p>
<h1><a class="anchor" id="Sec_Reports"></a>
USB-Reports</h1>
<p>Die Kommunikation mit und die Kontrolle des USB-Userport läuft über vorgegebene Reports. Das PC-Programm sendet und empfängt die Reports mittels der generischen HID-API des Betriebssystems. Der USB-Userport reagiert auf diese Reports. Alle Interfaceleitungen werden mit <code>In</code> <code>Reports</code> oder <code>Out</code> <code>Reports</code> gesteuert, spezielle Geräteeigenschaften werden durch <code>Feature</code> <code>Reports</code> kontrolliert.</p>
<p>Durch die Fülle an Möglichkeiten werden Report-IDs verwendet um die Kommandos und Datenpakete auseinander zu halten.</p>
<p>Die definierten USB-In- und -Out-Report-IDs: </p><table class="doxtable">
<tr>
<th><b>Report-ID</b> </th><th><b>Richtung</b> </th><th><b>Daten</b> </th><th><b>Beschreibung</b>  </th></tr>
<tr>
<td>0x01 </td><td>In </td><td>1 Byte <br  />
 <code>0000_00bb</code>  </td><td><b>Get Device LEDs</b> holt den Zustand der LEDs. LED leuchtet = Bit ist '1'. <br  />
 Bit 1 &lt;=&gt; Tx-LED <br  />
 Bit 0 &lt;=&gt; Rx-LED  </td></tr>
<tr>
<td>0x01 </td><td>Out </td><td>1 Byte <br  />
 <code>0000_00bb</code>  </td><td><b>Set Device LEDs</b> kontrolliert die LEDs. Bit ist '1' = LED leuchtet. <br  />
 Bit 1 &lt;=&gt; Tx-LED <br  />
 Bit 0 &lt;=&gt; Rx-LED  </td></tr>
<tr>
<td>0x02 </td><td>In </td><td>2 Bytes <br  />
 <code>bb0b_bbbb_bbbb_bbb0</code>  </td><td><b>Get GPIO1 States</b> holt die logischen Zustände der IO-Leitungen. Intel-Format, Bit 13 und Bit 0 sind nicht verfügbar.  </td></tr>
<tr>
<td>0x02 </td><td>Out </td><td>4 Bytes <br  />
 <code>bb0b_bbbb_bbbb_bbb0</code> <br  />
 <code>mm0m_mmmm_mmmm_mmm0</code>  </td><td><b>Set GPIO1 States</b> schreibt auf die IO-Leitungen oder aktiviert die Pull-Ups. Es werden nur die Bits ('b') geschrieben, deren Maske ('m') auf '1' liegt. Der Report hat keinen Effekt wenn die Maske 0x0000 vorliegt. Intel-Format, Bit 13 und Bit 0 sind nicht verfügbar.  </td></tr>
<tr>
<td>0x03 </td><td>In </td><td>2 Bytes <br  />
 <code>bb0b_bbbb_bbbb_bbb0</code>  </td><td><b>Get GPIO1 Directions</b> holt die Datenrichtungen der IO-Leitungen. Eine '1' bedeutet 'Ausgabe'. Intel-Format, Bit 13 und Bit 0 sind nicht verfügbar.   </td></tr>
<tr>
<td>0x03 </td><td>Out </td><td>4 Bytes <br  />
 <code>bb0b_bbbb_bbbb_bbb0</code> <br  />
 <code>mm0m_mmmm_mmmm_mmm0</code>  </td><td><b>Set GPIO1 Directions</b> kontrolliert die Datenrichtungen, eine '1' bedeutet 'Ausgabe'. Es werden nur die Bits ('b') geschrieben, deren Maske ('m') auf '1' liegt. Der Report hat keinen Effekt wenn die Maske 0x0000 vorliegt. Intel-Format, Bit 13 und Bit 0 sind nicht verfügbar.  </td></tr>
<tr>
<td>0x04 </td><td>In </td><td>2 Bytes <br  />
 <code>0000_0000_bbbb_0000</code>  </td><td><b>Get GPIO2 States</b> holt die logischen Zustände der IO-Leitungen. Intel-Format, nur Bit 7 bis Bit 4 sind verfügbar.  </td></tr>
<tr>
<td>0x04 </td><td>Out </td><td>4 Bytes <br  />
 <code>0000_0000_bbbb_0000</code> <br  />
 <code>0000_0000_mmmm_0000</code>  </td><td><b>Set GPIO2 States</b> schreibt auf die IO-Leitungen oder aktiviert die Pull-Ups. Es werden nur die Bits ('b') geschrieben, deren Maske ('m') auf '1' liegt. Der Report hat keinen Effekt wenn die Maske 0x0000 vorliegt. Intel-Format, nur Bit 7 bis Bit 4 sind verfügbar.  </td></tr>
<tr>
<td>0x05 </td><td>In </td><td>2 Bytes <br  />
 <code>0000_0000_bbbb_0000</code>  </td><td><b>Get GPIO2 Directions</b> holt die Datenrichtungen der IO-Leitungen. Eine '1' bedeutet 'Ausgabe'. Intel-Format, nur Bit 7 bis Bit 4 sind verfügbar.   </td></tr>
<tr>
<td>0x05 </td><td>Out </td><td>4 Bytes <br  />
 <code>0000_0000_bbbb_0000</code> <br  />
 <code>0000_0000_mmmm_0000</code>  </td><td><b>Set GPIO2 Directions</b> kontrolliert die Datenrichtungen, eine '1' bedeutet 'Ausgabe'. Es werden nur die Bits ('b') geschrieben, deren Maske ('m') auf '1' liegt. Der Report hat keinen Effekt wenn die Maske 0x0000 vorliegt. Intel-Format, nur Bit 7 bis Bit 4 sind verfügbar.  </td></tr>
<tr>
<td>0x0E </td><td>In </td><td>4 Bytes <br  />
 GPIO1: <code>cccc_cccc_cccc_cccc</code> <br  />
 GPIO2: <code>cccc_cccc_cccc_cccc</code>  </td><td><b>Get Change Control</b> holt die Einstellung des Änderungsmonitors. Die Änderungsüberwachung der IO-Leitung ist aktiv wenn das zugehörige Bit auf '1' steht. Die unteren beiden Bytes sind für GPIO1 zuständig, die oberen beiden Bytes für GPIO2. Intel-Format.  </td></tr>
<tr>
<td>0x0E </td><td>Out </td><td>4 Bytes <br  />
 GPIO1: <code>cccc_cccc_cccc_cccc</code> <br  />
 GPIO2: <code>cccc_cccc_cccc_cccc</code>  </td><td><b>Set Change Control</b> kontrolliert die Überwachung auf Zustandsänderung der IO-Leitungen. Die Änderungsüberwachung der IO-Leitung ist aktiv wenn das zugehörige Bit auf '1' steht. Die unteren beiden Bytes sind für GPIO1 zuständig, die oberen beiden Bytes für GPIO2. Intel-Format. <b>Changed Bits</b> reports können nur erzeugt werden wenn wenigstens ein Änderungsmonitor aktiv ist.  </td></tr>
<tr>
<td>0x0F </td><td>In </td><td>8 Bytes <br  />
 GPIO1: <code>bbbb_bbbb_bbbb_bbbb</code> <br  />
 GPIO1: <code>cccc_cccc_cccc_cccc</code> <br  />
 GPIO2: <code>bbbb_bbbb_bbbb_bbbb</code> <br  />
 GPIO2: <code>cccc_cccc_cccc_cccc</code>  </td><td><b>Changed Bits</b> liefert Änderungen der IO-Leitungen seit der letzten USB- Anfrage vom Host. Die ersten zwei Bytes spiegeln den Zustand der IO-Leitungen ('b') von GPIO1. Die nächsten zwei Bytes zeigen eine Änderung auf der zugehörigen Leitung ('c'). GPIO2 kommt danach mit der selben Struktur. Intel-Format. <em>Dieser Report wird automatisch gesendet, wenn der Host das Gerät nach Interrupt-In-Reports befragt, sofern denn eine Änderung statt fand. Das PC-Programm kann diesen Report nicht gezielt anfordern.</em>  </td></tr>
<tr>
<td>0x10 </td><td>Out </td><td>2 Bytes <br  />
 DIDR: <code>bbbb_0000</code> <br  />
 AREF: <code>o000_00r1</code>  </td><td><b>Set ADC</b> kontrolliert die analogen Eingänge. Schaltet den ADC an ('o' = 1) oder komplett aus ('o' = 0). Stellt die zentrale Referenzquelle (AREF) ein. 'r' schaltet die analoge Referenzspannung auf 2.56 V wenn gesetzt ('1'), auf AVcc wenn gelöscht ('0', default). 'b' schaltet die digitalen Eingangsstufen am zugehörigen GPIO ab (Stichwort: DIDR) wenn auf '1' gesetzt. <br  />
 <em>Die Einstellung des jeweiligen GPIO ist gemäß der Anwendung vorzunehmen!</em> Der jeweilige GPIO sollte als Eingang definiert werden und der Pull-Up ausgeschaltet sein. Für besondere Experimente sind alle GPIO-Möglichkeiten absichtlich weiterhin vorhanden.  </td></tr>
<tr>
<td>0x14 </td><td>In </td><td>2 Bytes <br  />
 <code>bbbb_bbbb_bb00_0000</code>  </td><td><b>Get ADC[4]</b> holt den aktuell anliegenden Spannungswert von ADC[4] ab. Die signifikanten Bits sind linksbündig ausgerichtet, die Bytereihenfolge entspricht dem Intel-Format. 0x0000 &lt;=&gt; 0 V, 0xFFC0 &lt;=&gt; AREF <br  />
 <em>Die Einstellung des GPIO (GPIO[4]) ist gemäß der Anwendung vorzunehmen!</em>  </td></tr>
<tr>
<td>0x15 </td><td>In </td><td>2 Bytes <br  />
 <code>bbbb_bbbb_bb00_0000</code>  </td><td><b>Get ADC[5]</b> holt den aktuell anliegenden Spannungswert von ADC[5] ab. Die signifikanten Bits sind linksbündig ausgerichtet, die Bytereihenfolge entspricht dem Intel-Format. 0x0000 &lt;=&gt; 0 V, 0xFFC0 &lt;=&gt; AREF <br  />
 <em>Die Einstellung des GPIO (GPIO[5]) ist gemäß der Anwendung vorzunehmen!</em>  </td></tr>
<tr>
<td>0x16 </td><td>In </td><td>2 Bytes <br  />
 <code>bbbb_bbbb_bb00_0000</code>  </td><td><b>Get ADC[6]</b> holt den aktuell anliegenden Spannungswert von ADC[6] ab. Die signifikanten Bits sind linksbündig ausgerichtet, die Bytereihenfolge entspricht dem Intel-Format. 0x0000 &lt;=&gt; 0 V, 0xFFC0 &lt;=&gt; AREF <br  />
 <em>Die Einstellung des GPIO (GPIO[6]) ist gemäß der Anwendung vorzunehmen!</em>  </td></tr>
<tr>
<td>0x17 </td><td>In </td><td>2 Bytes <br  />
 <code>bbbb_bbbb_bb00_0000</code>  </td><td><b>Get ADC[7]</b> holt den aktuell anliegenden Spannungswert von ADC[7] ab. Die signifikanten Bits sind linksbündig ausgerichtet, die Bytereihenfolge entspricht dem Intel-Format. 0x0000 &lt;=&gt; 0 V, 0xFFC0 &lt;=&gt; AREF <br  />
 <em>Die Einstellung des GPIO (GPIO[7]) ist gemäß der Anwendung vorzunehmen!</em>  </td></tr>
<tr>
<td>0x20 </td><td>In </td><td>2 Bytes <br  />
 Servo 1: <code>bbbb_bbbb</code> <br  />
 Servo 2: <code>bbbb_bbbb</code>  </td><td><b>Get Servos</b> holt die derzeit gültige Pulsdauer für das jeweilige Servo ab. Die Werte liegen im Bereich 0 bis 250.  </td></tr>
<tr>
<td>0x20 </td><td>Out </td><td>2 Bytes <br  />
 Servo 1: <code>bbbb_bbbb</code> <br  />
 Servo 2: <code>bbbb_bbbb</code>  </td><td><b>Set Servos</b> stellt die Pulsdauern im Bereich 0 (= 1000 µs) bis 250 (= 2000 µs) für das jeweilige Servo ein. Der Defaultwert ist 125 (= 1500 µs = Mittelstellung). <br  />
 Werte über 250 beeinflussen die Impulsdauer nicht, stattdessen werden sie zur Steuerung des Impulsgenerators des jeweiligen Servokanals verwendet: <br  />
 255 &lt;=&gt; neutraler Wert, Servoeinstellung wird nicht verändert. <br  />
 254 &lt;=&gt; reserviert, nicht benutzen! <br  />
 253 &lt;=&gt; Servologik einschalten, Impulsausgang anstelle GPIO. <br  />
 252 &lt;=&gt; reserviert, nicht benutzen! <br  />
 251 &lt;=&gt; reserviert, nicht benutzen! <br  />
 Siehe auch die <a class="el" href="index.html#Sec_Servo_Hinweise">Hinweise zum Servo-Betrieb</a> weiter unten.  </td></tr>
<tr>
<td>0xF8 </td><td>Out </td><td>2 Bytes </td><td><b>Set Address</b> übergibt die Adresse des IO-Registers für Schreib- oder Lesezugriffe.  </td></tr>
<tr>
<td>0xF9 </td><td>In </td><td>1 Byte </td><td><b>Read from Address</b> liest ein Byte vom vorgewählten IO-Register.  </td></tr>
<tr>
<td>0xF9 </td><td>Out </td><td>1 Byte </td><td><b>Write to Address</b> schreibt ein Byte zum vorgewählten IO-Register.  </td></tr>
</table>
<p>Die definierten USB-Feature-Report-IDs: </p><table class="doxtable">
<tr>
<th><b>Feature-ID</b> </th><th><b>Richtung</b> </th><th><b>Daten</b> </th><th><b>Beschreibung</b>  </th></tr>
<tr>
<td>0x2A </td><td>Out </td><td>7 Bytes Schlüssel <br  />
 <code>0x52</code> <code>0x65</code> <code>0x66</code> <code>0x6c</code> <code>0x61</code> <code>0x73</code> <code>0x68</code>  </td><td>Stoppt das USB-Interface und springt zum Bootlader, sofern der Schlüssel passt.  </td></tr>
</table>
<h1><a class="anchor" id="Sec_Options"></a>
Konfiguration Anpassen</h1>
<p>Es gibt am USB-Userport die einstellbaren Konfigurationsoptionen: </p><ul>
<li><a class="el" href="a00020.html#aab8a339805083b226c4d11d211d374ea">DEVICE_SERIAL_NUMBER</a> </li>
<li><a class="el" href="a00020.html#aca3991dfbe85dc14ce22e7dfffd17dfc">MAX_CURRENT_DRAW</a> </li>
<li><a class="el" href="a00020.html#a51f1b5dd58811d0028c967793a515699">POLLING_INTERVAL</a></li>
</ul>
<p>Diese sind in der Datei <a class="el" href="a00020.html" title="Applikationseinstellungen (Header File)">AppConfig.h</a> zu finden. Nach einer Änderung muss der Code neu übersetzt und in den Controller übertragen werden.</p>
<h1><a class="anchor" id="Sec_Hinweise"></a>
Einige Wichtige Hinweise</h1>
<p>Du kannst den hier vorgestellten USB-Userport so benutzen wie er ist oder auch an Deine Bedürfnisse anpassen.</p>
<p>Vor lauter Begeisterung über die neuen Möglichkeiten beachte bitte immer drei Dinge:</p>
<ul>
<li>Von Microchip Technology Inc bekam ich die Erlaubnis die VID/PID-Kombination 0x04D8 / 0xEBC7 für mein USB-Userport-Projekt zu benutzen. Diese Kombination darf nicht für andere USB-Geräte verwendet werden. </li>
<li>Das LUFA-Paket steht unter der MIT-Lizenz. Sie erfordert stets die Nennung der Urheber, etwa so: <div class="fragment"><div class="line">* The USB-Userport *</div>
<div class="line">Copyright 2020  René Trapp (rene [dot] trapp (-at-) web [dot] de)</div>
<div class="line"> </div>
<div class="line">* LUFA Library *</div>
<div class="line">Copyright 2017  Dean Camera (dean [at] fourwalledcubicle [dot] com)</div>
</div><!-- fragment --> </li>
<li>Der USB-Userport steht in der aktuellen Version unter der GPL 3.0 Lizenz. </li>
<li>Die jeweils verwendete Lizenz ist stets mit anzugeben.</li>
</ul>
<p>Das vollständige LUFA-Projekt ist auf der Seite <a href="http://www.lufa-lib.org">www.lufa-lib.org</a> zu finden. Der USB-Userport basiert auf dem LUFA Generic HID Demo. Für den USB-Userport verwende ich LUFA 170418; andere Versionen könnten auch funktionieren aber das habe ich nicht ausprobiert.</p>
<h1><a class="anchor" id="Sec_Servo_Hinweise"></a>
Hinweise zum Servo-Betrieb</h1>
<p>Die Impulserzeugung für die Servos hat die Eigenschaften </p><table class="doxtable">
<tr>
<td><b> Impulspolarität: </b> </td><td>positiv   </td></tr>
<tr>
<td><b> Impulsdauer min.: </b> </td><td>1000 µs  </td></tr>
<tr>
<td><b> Impulsdauer max.: </b> </td><td>2000 µs  </td></tr>
<tr>
<td><b> Wiederholrate: </b> </td><td>20000 µs  </td></tr>
</table>
<p>Erfahrungsgemäß ist es wichtig die Impulslängen im 'normgerechten' Bereich von 1 ms bis 2 ms zu halten. Pulslängen ausserhalb dieser Grenzen führen oft zu einer Überlastung des Getriebes und zur Zerstörung der Servomechanik. Es ist daher besonderes Augenmerk darauf zu legen, dass niemals ein Servo an einen Standard GPIO angeschlossen wird der mit falschem Timing schaltet. Bereits kurze Störimpulse können das Servo gegen einen Anschlag laufen lassen und mechanisch zerstören. Daher ist dafür zu sorgen, dass ein als Eingang geschalteter GPIO ans Servo eine dauerhafte '0' übermittelt. Auch ein ausgeschalteter USB-Userport muss ans Servo eine '0' übermitteln. Nur im Falle eines aktiv eingeschalteten GPIO (= Ausgang) auf '1' erhält das Servo eine '1'. Die ansteigende Flanke wird das Servo starten, die meisten aktuellen Servos stoppen wenn keine weitere Flanke nachfolgt. Ein zu kurzer Impuls, beispielsweise weil der USB-Userport während des Impulses ausgeschaltet wird, lässt das Servo zwar kurz loslaufen, es stoppt aber sehr schnell wieder.</p>
<p>Ohne Impuls erfolgt keine (schädliche) Bewegung des Servos. Dies ermöglicht es das Servo an einen GPIO angeschlossen zu haben, bevor der USB-Userport für den Anwendungsfall konfiguriert ist.</p>
<dl class="section note"><dt>Zu beachten</dt><dd>Es liegt in der Verantwortung des Host-Programms die Datenrichtungen und die Portausgangsregister der beiden GPIOs für die Servos nicht zu verändern wenn sie zur Servokontrolle verwendet werden sollen!</dd></dl>
<p>Weiterhin liegt die Stromaufnahme eines Servos deutlich über der erlaubten Strombelastbarkeit eines USB-Ports und belastet auch die Versorgungselektronik des USB-Userport erheblich. Es wird daher dringend empfohlen eine eigene und ausreichend belastbare Versorgung für die Servos zu verwenden. Diese Versorgung wird unabhängig von der USB-Versorgung sein und insbesondere kann die jeweils andere Versorgung gerade ausgeschaltet sein.</p>
<p>Nun gibt es mehrere Möglichkeiten ein Servo mit dem USB-Userport zu verbinden. Im einfachsten Fall wird der Impulsausgang direkt an den entsprechenden Anschluß des Servos geführt. Falls die Elektronik eine überhöhte Spannung in den µC-Anschluß gibt, wird dieser beschädigt. Auch wenn das Servo abgeschaltet ist, könnten Impulse vom µC das Servo schädigen. Es sollte zumindest ein Widerstand zum Schutz in diese Leitung eingefügt werden.</p>
<div class="image">
<img src="Servo Direct.png" alt=""/>
<div class="caption">
Direkte Servoansteuerung</div></div>
 <p>Als Luxusversion gibt es noch eine Variante mit zwei Transistoren und 4 Widerständen, die diese Gesichtspunkte berücksichtigt. Die Schaltung passt gleichzeitig die logischen Pegel des Impulses vom USB-Userport an die Versorgungsspannung des Servos an.</p>
<div class="image">
<img src="Servo.png" alt=""/>
<div class="caption">
Servoansteuerung mit Pegelanpassung</div></div>
 <p>Das Einschalten der Servologik ist einfach, es wird lediglich der zugehörige USB-Report vom Host gesendet. Es ergeben sich 3 Möglichkeiten: </p><ul>
<li>Nur Servo 1 initialisieren, GPIO[5] als Ausgang schalten <div class="fragment"><div class="line">Send_HID_Report(REPORT_ID_SERVO_PWM, 253, 255)</div>
</div><!-- fragment --> </li>
<li>Nur Servo 2 initialisieren, GPIO[6] als Ausgang schalten <div class="fragment"><div class="line">Send_HID_Report(REPORT_ID_SERVO_PWM, 255, 253)</div>
</div><!-- fragment --> </li>
<li>Beide Servos initialisieren, GPIO[5] und GPIO[6] als Ausgang schalten <div class="fragment"><div class="line">Send_HID_Report(REPORT_ID_SERVO_PWM, 253, 253)</div>
</div><!-- fragment --> Die Initialisierung funktioniert ohne unerwünschte Störimpulse. Bedingt durch die Hardware dauert es 20 ms bis der erste Impuls zum Servo gesendet wird. Nach einer Initialisierung bleibt die jeweilige Servologik bis zum nächsten RESET in Betrieb und der zugehörige GPIO ist nicht anderweitig verwendbar. Eine Abschaltung des Impulsgenerators ist nicht vorgesehen.</li>
</ul>
<p>Die initiale Pulslänge von 1500 µs bringt das Servo in seine Mittelstellung. Es ist möglich die Vorgabewerte für die Servos bereits zu senden, ohne dass die Servologik eingeschaltet ist. Dadurch können von der Mittelstellung abweichende Startpositionen realisiert werden. Zum Beispiel: </p><div class="fragment"><div class="line">Send_HID_Report(REPORT_ID_SERVO_PWM, 50, 200)</div>
<div class="line">Send_HID_Report(REPORT_ID_SERVO_PWM, 253, 253)</div>
</div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Erzeugt am Sam Apr 17 2021 00:17:08 für USB-Userport von
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
