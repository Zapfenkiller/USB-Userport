<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>USB-Userport: USB-Userport</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">USB-Userport
   </div>
   <div id="projectbrief">Exploit generic HID class to connect PC application programs to your electronics lab bench.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">USB-Userport </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Decades ago hardware hackers, computer enthusiasts and electronic developers have had hardware interfaces easy to access from outside and inside the computer. Just a matching connector, some wiring and proper coding had been sufficient.</p>
<p>Modern operating systems do not give easy access to the computer's hardware interfaces. Special drivers could be downloaded from the web but there is the risk of unknown software and it is necessary to provide administrator credentials to those installers. Not everyone has full administrator rights on a particular machine. This is especially true with large enterprises laboratories or education purposes.</p>
<p>But even if those restrictions do not apply to your PC, recent computer hardware lacks the 'legacy' interfaces so there is no user accessible input/output hardware at all. Instead USB has become widespread. Luckily those modern operating systems, denying direct hardware access from user program code, provide generic drivers to access certain USB devices attached. Luckily there is this Arduino microcosmos dedicated to education. As it turns out, there are some cheap boards around that allow for direct USB usage - without the USB-serial-UART detour. And finally Dean Camera made his wonderful <a href="http://www.lufa-lib.org">LUFA</a> project to interface at least several Atmel controllers to USB.</p>
<p>Combining all this stuff together and learning how to exploit the OS generic USB drivers a USB device can be made to directly control hardware lines from user applications. Okay, not as directly and fast as with those old days <code>in</code> and <code>out</code> commands. But at least it is a door to add goodies modern computers lack.</p>
<h1><a class="anchor" id="Sec_Info"></a>
USB Information</h1>
<p>The following table gives a rundown of the USB utilization of the USB-Userport.</p>
<table class="doxtable">
<tr>
<td><b>USB Class:</b>  </td><td>Human Interface Device (HID) </td></tr>
<tr>
<td><b>USB Subclass:</b>  </td><td>N/A  </td></tr>
<tr>
<td><b>USB Mode:</b>  </td><td>Device  </td></tr>
<tr>
<td><b>Vendor ID:</b>  </td><td>0x04D8  </td></tr>
<tr>
<td><b>Product ID:</b>  </td><td>0xEBC7  </td></tr>
<tr>
<td><b>Max. Current Draw:</b>  </td><td>100 mA  </td></tr>
<tr>
<td><b>Polling Intervall:</b>  </td><td>5 ms  </td></tr>
<tr>
<td><b>Relevant Standards:</b>  </td><td><a href="https://www.usb.org/sites/default/files/documents/hid1_11.pdf">USBIF HID Specification</a> <br  />
 <a href="https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf">USBIF HID Usage Tables</a> </td></tr>
<tr>
<td><b>Supported USB Speeds:</b>  </td><td>Full Speed Mode <br  />
 (Low Speed Mode) </td></tr>
</table>
<p>The USB-Userport as is, compiles to use Full Speed Mode. LUFA can support compilation for Low Speed Mode. But this is neither tested, nor recommended.</p>
<h1><a class="anchor" id="Sec_Description"></a>
Project Description</h1>
<p>The USB-Userport turns a <a href="https://www.sparkfun.com/products/12640">Sparkfun ProMicro</a> into a versatile interface device for your computer application. Eventually a <a href="https://www.sparkfun.com/products/15795">Sparkfun Qwiic Pro Micro</a> could also do the job without changes. It gives input and output lines to PC application programs without the need to install special drivers. The generic HID driver of your OS connects to the hardware part. Any PC application can access the IO-lines by using dedicated reports. The mapping from USB control to ProMicro IO-lines is as follows: </p><table class="doxtable">
<tr>
<th><b>USB-Userport</b>  </th><th><b>ProMicro</b>  </th></tr>
<tr>
<td>LED[0]  </td><td>RX-LED  </td></tr>
<tr>
<td>LED[1]  </td><td>TX-LED  </td></tr>
<tr>
<td>GPIO1[0]  </td><td>-n/a-  </td></tr>
<tr>
<td>GPIO1[1]  </td><td>15  </td></tr>
<tr>
<td>GPIO1[2]  </td><td>16  </td></tr>
<tr>
<td>GPIO1[3]  </td><td>14  </td></tr>
<tr>
<td>GPIO1[4]  </td><td>8  </td></tr>
<tr>
<td>GPIO1[5] - Servo 1  </td><td>9  </td></tr>
<tr>
<td>GPIO1[6] - Servo 2  </td><td>10  </td></tr>
<tr>
<td>GPIO1[7]  </td><td>5  </td></tr>
<tr>
<td>GPIO1[8]  </td><td>3  </td></tr>
<tr>
<td>GPIO1[9]  </td><td>2  </td></tr>
<tr>
<td>GPIO1[10]  </td><td>0  </td></tr>
<tr>
<td>GPIO1[11]  </td><td>1  </td></tr>
<tr>
<td>GPIO1[12]  </td><td>4  </td></tr>
<tr>
<td>GPIO1[13]  </td><td>-n/a-  </td></tr>
<tr>
<td>GPIO1[14]  </td><td>7  </td></tr>
<tr>
<td>GPIO1[15]  </td><td>6  </td></tr>
<tr>
<td>GPIO2[0]  </td><td>-n/a-  </td></tr>
<tr>
<td>GPIO2[1]  </td><td>-n/a-  </td></tr>
<tr>
<td>GPIO2[2]  </td><td>-n/a-  </td></tr>
<tr>
<td>GPIO2[3]  </td><td>-n/a-  </td></tr>
<tr>
<td>GPIO2[4] - ADC[4]  </td><td>21  </td></tr>
<tr>
<td>GPIO2[5] - ADC[5]  </td><td>20  </td></tr>
<tr>
<td>GPIO2[6] - ADC[6]  </td><td>19  </td></tr>
<tr>
<td>GPIO2[7] - ADC[7]  </td><td>18  </td></tr>
<tr>
<td>GPIO2[8]  </td><td>-n/a-  </td></tr>
<tr>
<td>GPIO2[9]  </td><td>-n/a-  </td></tr>
<tr>
<td>GPIO2[10]  </td><td>-n/a-  </td></tr>
<tr>
<td>GPIO2[11]  </td><td>-n/a-  </td></tr>
<tr>
<td>GPIO2[12]  </td><td>-n/a-  </td></tr>
<tr>
<td>GPIO2[13]  </td><td>-n/a-  </td></tr>
<tr>
<td>GPIO2[14]  </td><td>-n/a-  </td></tr>
<tr>
<td>GPIO2[15]  </td><td>-n/a-  </td></tr>
</table>
<p>When attached to the USB, the host will enumerate the USB-Userport as a custom (vendor defined) HID device. Your application program can send and receive reports by both the standard data endpoint and control request methods as defined in the <a href="https://www.usb.org/sites/default/files/documents/hid1_11.pdf">USB HID specification</a>.</p>
<p>One special feature report allows a device hardware reset into the bootloader. This is dedicated to development purposes.</p>
<h1><a class="anchor" id="Sec_Reports"></a>
USB Reports</h1>
<p>Communication with and control of the USB-Userport is done by exchanging reports. The host application (running on the PC) sends or receives those reports using the OS generic HID API. The USB-Userport device reacts upon those reports. All I/O-lines are controlled using <code>In</code> <code>Reports</code> or <code>Out</code> <code>Reports</code>, special device control is done using <code>Feature</code> <code>Reports</code>.</p>
<p>Due to the wealth of accessible controls, IDs are used to distinguish the commands and messages.</p>
<p>USB-Report IDs defined: </p><table class="doxtable">
<tr>
<th><b>Report ID</b> </th><th><b>Direction</b> </th><th><b>Payload</b> </th><th><b>Description</b>  </th></tr>
<tr>
<td>0x01 </td><td>In </td><td>1 Byte <br  />
 <code>0000_00bb</code>  </td><td><b>Get Device LEDs</b> returns the LED states. LED is lit = bit is '1'. <br  />
 Bit 1 &lt;=&gt; Tx-LED <br  />
 Bit 0 &lt;=&gt; Rx-LED  </td></tr>
<tr>
<td>0x01 </td><td>Out </td><td>1 Byte <br  />
 <code>0000_00bb</code>  </td><td><b>Set Device LEDs</b> controls the LEDs. Bit is '1' = LED is lit. <br  />
 Bit 1 &lt;=&gt; Tx-LED <br  />
 Bit 0 &lt;=&gt; Rx-LED  </td></tr>
<tr>
<td>0x02 </td><td>In </td><td>2 Bytes <br  />
 <code>bb0b_bbbb_bbbb_bbb0</code>  </td><td><b>Get GPIO1 States</b> returns the port line logical states. Little endian byte order, bit 13 and bit 0 are not available.  </td></tr>
<tr>
<td>0x02 </td><td>Out </td><td>4 Bytes <br  />
 <code>bb0b_bbbb_bbbb_bbb0</code> <br  />
 <code>mm0m_mmmm_mmmm_mmm0</code>  </td><td><b>Set GPIO1 States</b> controls the output lines or input-pull-up circuitry. Each bit ('b') is only copied to the port if the mask ('m') position is '1'. No effect at all if mask is 0x0000. Little endian byte order, bit 13 and bit 0 are not available.  </td></tr>
<tr>
<td>0x03 </td><td>In </td><td>2 Bytes <br  />
 <code>bb0b_bbbb_bbbb_bbb0</code>  </td><td><b>Get GPIO1 Directions</b> returns the port line directions. A '1' means output. Little endian byte order, bit 13 and bit 0 are not available.   </td></tr>
<tr>
<td>0x03 </td><td>Out </td><td>4 Bytes <br  />
 <code>bb0b_bbbb_bbbb_bbb0</code> <br  />
 <code>mm0m_mmmm_mmmm_mmm0</code>  </td><td><b>Set GPIO1 Directions</b> controls the output lines direction. A '1' means output. Each bit ('b') is only copied to the port if the mask ('m') position is '1'. No effect at all if mask is 0x0000. Little endian byte order, bit 13 and bit 0 are not available.  </td></tr>
<tr>
<td>0x04 </td><td>In </td><td>2 Bytes <br  />
 <code>0000_0000_bbbb_0000</code>  </td><td><b>Get GPIO2 States</b> returns the port line logical states. Little endian byte order, only bit 7 downto bit 4 are available.  </td></tr>
<tr>
<td>0x04 </td><td>Out </td><td>4 Bytes <br  />
 <code>0000_0000_bbbb_0000</code> <br  />
 <code>0000_0000_mmmm_0000</code>  </td><td><b>Set GPIO2 States</b> controls the output lines or input-pull-up circuitry. Each bit ('b') is only copied to the port if the mask ('m') position is '1'. No effect at all if mask is 0x0000. Little endian byte order, only bit 7 downto bit 4 are available.  </td></tr>
<tr>
<td>0x05 </td><td>In </td><td>2 Bytes <br  />
 <code>0000_0000_bbbb_0000</code>  </td><td><b>Get GPIO2 Directions</b> returns the port line directions. A '1' means output. Little endian byte order, only bit 7 downto bit 4 are available.   </td></tr>
<tr>
<td>0x05 </td><td>Out </td><td>4 Bytes <br  />
 <code>0000_0000_bbbb_0000</code> <br  />
 <code>0000_0000_mmmm_0000</code>  </td><td><b>Set GPIO2 Directions</b> controls the output lines direction. A '1' means output. Each bit ('b') is only copied to the port if the mask ('m') position is '1'. No effect at all if mask is 0x0000. Little endian byte order, only bit 7 downto bit 4 are available.  </td></tr>
<tr>
<td>0x0E </td><td>In </td><td>4 Bytes <br  />
 GPIO1: <code>cccc_cccc_cccc_cccc</code> <br  />
 GPIO2: <code>cccc_cccc_cccc_cccc</code>  </td><td><b>Get Change Control</b> returns the change monitor settings. A '1' means the respective checking is enabled. The lower 2 bytes control GPIO1, the upper 2 bytes control GPIO2. Little endian byte order.  </td></tr>
<tr>
<td>0x0E </td><td>Out </td><td>4 Bytes <br  />
 GPIO1: <code>cccc_cccc_cccc_cccc</code> <br  />
 GPIO2: <code>cccc_cccc_cccc_cccc</code>  </td><td><b>Set Change Control</b> enables monitoring of bit changes. Set bit to '1' to enable the respective checking. The lower 2 bytes control GPIO1, the upper 2 bytes control GPIO2. Little endian byte order. If at least one bit change monitor is enabled, <b>Changed Bits</b> reports might get issued by the USB-Userport.  </td></tr>
<tr>
<td>0x0F </td><td>In </td><td>8 Bytes <br  />
 GPIO1: <code>bbbb_bbbb_bbbb_bbbb</code> <br  />
 GPIO1: <code>cccc_cccc_cccc_cccc</code> <br  />
 GPIO2: <code>bbbb_bbbb_bbbb_bbbb</code> <br  />
 GPIO2: <code>cccc_cccc_cccc_cccc</code>  </td><td><b>Changed Bits</b> reports bit positions changed since the last cyclic USB-poll. The first 2 bytes mirror the GPIO1 port line states ('b'). The next 2 bytes flag line changes of the corresponding position ('c'). GPIO2 follows thereafter with the same structure. Little endian byte order. <em>This report is automatically sent when the USB host polls the device's Interrupt In endpoint for changes, if a change occured at all. The user application cannot request this report on its own.</em>   </td></tr>
<tr>
<td>0x10 </td><td>Out </td><td>2 Bytes <br  />
 DIDR: <code>bbbb_0000</code> <br  />
 AREF: <code>o000_00r1</code>  </td><td><b>Set ADC</b> controls analog inputs. Turns the ADC on ('o' = 1) or off ('o' = 0). Manages the central voltage reference (AREF). It gives 2.56 V if 'r' is set ('1'), AVcc if clear ('0', default). When the corresponding bit position 'b' is set the digital input circuitry is disabled. <br  />
 <em>The respective GPIO shall be set according to the intended application!</em> Each GPIO should get defined as input and the pull-up circuitry turned off. The regular GPIO control still is available to allow for special experiments.   </td></tr>
<tr>
<td>0x14 </td><td>In </td><td>2 Bytes <br  />
 ADC4: <code>bbbb_bbbb_bb00_0000</code>  </td><td><b>Get ADC[4]</b> returns the recent voltage of ADC[4]. The significant bits are left adjusted. Little endian byte order. 0x0000 &lt;=&gt; 0 V, 0xFFC0 &lt;=&gt; AREF <br  />
 <em>GPIO[4] shall be set according to the intended application!</em>  </td></tr>
<tr>
<td>0x15 </td><td>In </td><td>2 Bytes <br  />
 ADC5: <code>bbbb_bbbb_bb00_0000</code>  </td><td><b>Get ADC[5]</b> returns the recent voltage of ADC[5]. The significant bits are left adjusted. Little endian byte order. 0x0000 &lt;=&gt; 0 V, 0xFFC0 &lt;=&gt; AREF <br  />
 <em>GPIO[5] shall be set according to the intended application!</em>  </td></tr>
<tr>
<td>0x16 </td><td>In </td><td>2 Bytes <br  />
 ADC6: <code>bbbb_bbbb_bb00_0000</code>  </td><td><b>Get ADC[6]</b> returns the recent voltage of ADC[6]. The significant bits are left adjusted. Little endian byte order. 0x0000 &lt;=&gt; 0 V, 0xFFC0 &lt;=&gt; AREF <br  />
 <em>GPIO[6] shall be set according to the intended application!</em>  </td></tr>
<tr>
<td>0x17 </td><td>In </td><td>2 Bytes <br  />
 ADC7: <code>bbbb_bbbb_bb00_0000</code>  </td><td><b>Get ADC[7]</b> returns the recent voltage of ADC[7]. The significant bits are left adjusted. Little endian byte order. 0x0000 &lt;=&gt; 0 V, 0xFFC0 &lt;=&gt; AREF <br  />
 <em>GPIO[7] shall be set according to the intended application!</em>  </td></tr>
<tr>
<td>0x20 </td><td>In </td><td>2 Bytes <br  />
 Servo 1: <code>bbbb_bbbb</code> <br  />
 Servo 2: <code>bbbb_bbbb</code>  </td><td><b>Get Servos</b> returns the recent pulse widths of the servos. The value range is 0 to 250.  </td></tr>
<tr>
<td>0x20 </td><td>Out </td><td>2 Bytes <br  />
 Servo 1: <code>bbbb_bbbb</code> <br  />
 Servo 2: <code>bbbb_bbbb</code>  </td><td><b>Set Servos</b> sets the pulse widths sent out to the servos. The range is (= 1000 µs) to 250 (= 2000 µs). The default is 125 (= 1500 µs = mid position). <br  />
 Values above 250 will not take effect on the pulse width, instead those are used to control the pulse width generator of each servo: <br  />
 255 &lt;=&gt; neutral value, never changes servo settings. <br  />
 254 &lt;=&gt; reserved, do not use! <br  />
 253 &lt;=&gt; turn on pulse generation, take over GPIO control. <br  />
 252 &lt;=&gt; reserved, do not use! <br  />
 251 &lt;=&gt; reserved, do not use! <br  />
 Please see also the <a class="el" href="index.html#Sec_Servo_Hints">Some Hints On Using RC-Servos</a> below.  </td></tr>
<tr>
<td>0xF8 </td><td>Out </td><td>2 Bytes </td><td><b>Set Address</b> sets the address for subsequent IO register accesses.  </td></tr>
<tr>
<td>0xF9 </td><td>In </td><td>1 Byte </td><td><b>Read from Address</b> reads one byte from the addressed IO register location.  </td></tr>
<tr>
<td>0xF9 </td><td>Out </td><td>1 Byte </td><td><b>Write to Address</b> writes one byte to the addressed IO register location.  </td></tr>
</table>
<p>USB-Feature IDs defined: </p><table class="doxtable">
<tr>
<th><b>Feature ID</b> </th><th><b>Direction</b> </th><th><b>Payload</b> </th><th><b>Description</b>  </th></tr>
<tr>
<td>0x2A </td><td>Out </td><td>7 Bytes key sequence <br  />
 <code>0x52</code> <code>0x65</code> <code>0x66</code> <code>0x6c</code> <code>0x61</code> <code>0x73</code> <code>0x68</code>  </td><td>Stop the device immediately and start the bootloader, if the key matches.  </td></tr>
</table>
<h1><a class="anchor" id="Sec_Options"></a>
Configuration Options</h1>
<p>The USB-Userport can get customized using those configuration options: </p><ul>
<li><a class="el" href="a00020.html#aab8a339805083b226c4d11d211d374ea">DEVICE_SERIAL_NUMBER</a> </li>
<li><a class="el" href="a00020.html#aca3991dfbe85dc14ce22e7dfffd17dfc">MAX_CURRENT_DRAW</a> </li>
<li><a class="el" href="a00020.html#a51f1b5dd58811d0028c967793a515699">POLLING_INTERVAL</a></li>
</ul>
<p>The definitions are collected in the file <a class="el" href="a00020.html" title="Application Configuration Header File.">AppConfig.h</a>. After changes have been done the code needs to get compiled and flashed into the µC again.</p>
<h1><a class="anchor" id="Sec_Notes"></a>
Some Important Notes</h1>
<p>Use the USB-Userport as is or rework it to exactly fit your needs.</p>
<p>While having fun and enjoying you please respect three things:</p>
<ul>
<li>Microchip Technology Inc gave me permission to use the VID/PID combination 0x04D8 / 0xEBC7 with the USB-Userport project solely. It is not allowed to use it for other USB-devices. </li>
<li>The MIT license gives maximum flexibility to your usage but it still requires your attribution to the work of Dean and me, like this: <div class="fragment"><div class="line">* The USB-Userport *</div>
<div class="line">Copyright 2020  René Trapp (rene [dot] trapp (-at-) web [dot] de)</div>
<div class="line"> </div>
<div class="line">* LUFA Library *</div>
<div class="line">Copyright 2017  Dean Camera (dean [at] fourwalledcubicle [dot] com)</div>
</div><!-- fragment --> </li>
<li>The respective license shall always be added.</li>
</ul>
<p>You can find the complete LUFA project at <a href="http://www.lufa-lib.org">www.lufa-lib.org</a>. The USB-Userport uses the LUFA Generic HID demo as its foundation. The USB-Userport is made with LUFA 170418, others eventually could also do. This I have not tested.</p>
<h1><a class="anchor" id="Sec_Servo_Hints"></a>
Some Hints On Using RC-Servos</h1>
<p>The pulse generator has got those properties: </p><table class="doxtable">
<tr>
<td><b> Pulse polarity: </b> </td><td>positive   </td></tr>
<tr>
<td><b> Min. pulse width: </b> </td><td>1000 µs  </td></tr>
<tr>
<td><b> Max. pulse width: </b> </td><td>2000 µs  </td></tr>
<tr>
<td><b> Repetition rate: </b> </td><td>20000 µs  </td></tr>
</table>
<p>By experience it is important to keep the pulse width in the standard range from 1 ms to 2 ms. Pulse widths outside this range often lead to mechanic overload of the gearbox and its damage. It is necessary to avoid connecting a servo to a GPIO that gives a wrong pulse width. Even short glitches could trigger the servo to run into one of its limit stops. From this it is mandatory that any GPIO defined as an input is interpreted as logical '0' by the servo electronics. The same is true for an unpowered USB-Userport. Only in case a GPIO drives actively a logical '1' this shall get forwarded to the servo. Recent servos stop running after a while if the pulse train stops. One too short pulse might trigger the servo to run but it will stop by itself after a short while.</p>
<p>Without any pulse the servo mechanism will not move at all. This fact allows to connect any servo to an uninitialized GPIO of the USB-Userport.</p>
<dl class="section note"><dt>Note</dt><dd>It is the responsibility of the host application to never change data directions nor port data registers of the both GPIOs dedicated to servo control when a servo is getting attached!</dd></dl>
<p>Since most servos' current draw exceeds the current capability of the USB-Userport it is highly recommended to use a separate power supply to the servo. This supply will be independent of the supply of the USB-Userport; hence one of those might be turned off while the other one is powered.</p>
<p>Now there are several possibilities to connect one servo to one pulse output of the USB-Userport. The most simple setup directly connects the pulse signal output of the USB-Userport to the pulse input of the servo electronics. In case the servo electronic returns some too high voltage to the USB-Userport, this gets damaged. The same might be true for pulses receiving at an unpowered servo. The servo or the USB-Userport (or even both) might suffer from electric overstress. To give some basic protection a resistor should get inserted into this connection, at least.</p>
<div class="image">
<img src="Servo Direct.png" alt=""/>
<div class="caption">
Direct Servo Connection</div></div>
 <p>A more sophisticated variant uses 2 transistors and 4 resistors to cope with those aspects. As a benefit this circuitry will adapt the output voltage levels of the USB-Userport to the supply voltage levels of the servo.</p>
<div class="image">
<img src="Servo.png" alt=""/>
<div class="caption">
Servo Connection With Level Shifting</div></div>
 <p>Initializing the servo pulse generation is quite simple. Just the dedicated USB report needs to get send by the host application. There are 3 variants: </p><ul>
<li>Initialize Servo 1 solely, GPIO[5] gets the pulse output <div class="fragment"><div class="line">Send_HID_Report(REPORT_ID_SERVO_PWM, 253, 255)</div>
</div><!-- fragment --> </li>
<li>Initialize Servo 2 solely, GPIO[6] gets the pulse output <div class="fragment"><div class="line">Send_HID_Report(REPORT_ID_SERVO_PWM, 255, 253)</div>
</div><!-- fragment --> </li>
<li>Initialize both servos, GPIO[5] and GPIO[6] get pulse outputs <div class="fragment"><div class="line">Send_HID_Report(REPORT_ID_SERVO_PWM, 253, 253)</div>
</div><!-- fragment --> The initialization is glitch free. Due to hardware properties it takes 20 ms until the first pulse is generated to the servo. After the initialization the respective pulse generator stays active until a RESET occurs. The associated GPIO keeps unavailable for other user purposes. There is no shutdown of the servo pulse generation intended.</li>
</ul>
<p>The initial pulse width of 1500 µs moves the servo shaft to its mid position. It is possible to adjust the pulse width start values before the pulse generator is initalized at all. This allows for start positions other than the mid position. E. g.: </p><div class="fragment"><div class="line">Send_HID_Report(REPORT_ID_SERVO_PWM, 50, 200)</div>
<div class="line">Send_HID_Report(REPORT_ID_SERVO_PWM, 253, 253)</div>
</div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Apr 15 2021 09:33:54 for USB-Userport by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
